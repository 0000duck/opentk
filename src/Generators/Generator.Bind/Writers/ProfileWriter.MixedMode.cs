using System;
using System.IO;
using System.Linq;
using System.Threading.Tasks;
using Bind.Structure;

namespace Bind.Writers
{
    internal partial class ProfileWriter
    {
        /// <summary>
        /// Writes a mixed mode class for the given project.
        /// </summary>
        /// <param name="project">The project to write a mixed-mode class for.</param>
        /// <param name="name">The full name of an API profile (e.g. OpenGL or OpenGLES).</param>
        /// <param name="dir">The directory to write mixed-mode class parts to.</param>
        /// <param name="ns">The namespace of the mixed-mode-class.</param>
        /// <param name="ext">Whether this project is an extension or not.</param>
        /// <param name="prefix">The prefix for this profile.</param>
        /// <param name="file">
        /// The mixed-mode file name without the extension or suffixes. This is usually the core mixed-mode name
        /// (i.e. GL) or the translated extension name.
        /// </param>
        /// <param name="exn">The extension name.</param>
        /// <param name="rootNamespace">The root namespace for the whole profile.</param>
        /// <returns>An asynchronous task.</returns>
        public static async Task WriteMixedModeClassAsync(Project project, string name, string dir, string ns, bool ext, string prefix, string file, string exn, string rootNamespace)
        {
            var exname = prefix.ToUpper() + "_" + exn;
            await WriteOverloadsMixedModePartAsync(project, name, Path.Combine(dir, $"{file}.Overloads.cs"), ns, prefix, rootNamespace);
            await WriteNativeMixedModePartAsync(project, name, Path.Combine(dir, $"{file}.Native.cs"), ns, ext, exname, rootNamespace);
            if (!File.Exists(Path.Combine(dir, $"{file}.cs")) && !ext)
            {
                await WriteTemplateMixedModePartAsync(project, name, Path.Combine(dir, $"{file}.cs"), ns, false);
            }
        }

        private static async Task WriteNativeMixedModePartAsync
            (Project project, string name, string file, string ns, bool ext, string exn, string rootNamespace)
        {
            var sw = new StreamWriter(File.Open(file, FileMode.Create, FileAccess.ReadWrite, FileShare.Inheritable));
            await sw.WriteLineAsync("// <auto-generated />");
            await sw.WriteLineAsync(EmbeddedResources.LicenseText(Path.GetFileName(file)));
            await sw.WriteLineAsync("using AdvancedDLSupport;");
            await sw.WriteLineAsync("using OpenToolkit.Core.Native;");
            await sw.WriteLineAsync("using OpenToolkit.Core.Loader;");
            await sw.WriteLineAsync("using OpenToolkit.Core.Extensions;");
            await sw.WriteLineAsync("using " + rootNamespace + ";");
            await sw.WriteLineAsync("using System;");
            await sw.WriteLineAsync("using System.Runtime.InteropServices;");
            await sw.WriteLineAsync("using System.Text;");
            await sw.WriteLineAsync();
            await sw.WriteLineAsync("namespace " + ns);
            await sw.WriteLineAsync("{");
            if (ext)
            {
                await sw.WriteLineAsync($"    [Extension(\"{exn}\")]");
            }

            await sw.WriteAsync("    public abstract partial class " + name);
            if (ext)
            {
                await sw.WriteLineAsync(" : ExtensionBase");
                await sw.WriteLineAsync("    {");
                await sw.WriteLineAsync("        /// <inheritdoc cref=\"ExtensionBase\"/>");
                await sw.WriteLineAsync($"        protected {name}(string path, ImplementationOptions options)");
                await sw.WriteLineAsync("            : base(path, options)");
                await sw.WriteLineAsync("        {");
                await sw.WriteLineAsync("        }");
                await sw.WriteLineAsync();
            }
            else
            {
                await sw.WriteLineAsync();
                await sw.WriteLineAsync("    {");
            }

            foreach (var func in project.Interfaces.SelectMany(x => x.Functions))
            {
                await sw.WriteLineAsync("        /// <inheritdoc/>");
                await sw.WriteAsync("        public abstract ");
                await sw.WriteLineAsync(GetDeclarationString(func) + ";");
                await sw.WriteLineAsync();
            }

            await sw.WriteLineAsync("    }");
            await sw.WriteLineAsync("}");
            sw.Dispose();
        }

        private static async Task WriteOverloadsMixedModePartAsync(Project project, string name, string file, string ns, string prefix, string rootNamespace)
        {
            var sw = new StreamWriter(File.Open(file, FileMode.Create, FileAccess.ReadWrite, FileShare.Inheritable));
            await sw.WriteLineAsync("// <auto-generated />");
            await sw.WriteLineAsync(EmbeddedResources.LicenseText(Path.GetFileName(file)));
            await sw.WriteLineAsync("using AdvancedDLSupport;");
            await sw.WriteLineAsync("using OpenToolkit.Core.Native;");
            await sw.WriteLineAsync("using OpenToolkit.Core.Extensions;");
            await sw.WriteLineAsync("using System;");
            await sw.WriteLineAsync("using System.Runtime.InteropServices;");
            await sw.WriteLineAsync("using System.Text;");
            await sw.WriteLineAsync("using " + rootNamespace + ";");
            await sw.WriteLineAsync();
            await sw.WriteLineAsync("namespace " + ns);
            await sw.WriteLineAsync("{");
            await sw.WriteLineAsync("    public partial class " + name);
            await sw.WriteLineAsync("    {");
            foreach (var overload in project.Overloads)
            {
                await sw.WriteLineAsync
                (
                    $"        " +
                    $"[AutoGenerated(" +
                    $"Category = \"{overload.Item1.Categories.First()}\", " +
                    $"Version = \"{overload.Item1.IntroducedIn}\", " +
                    $"EntryPoint = \"{prefix}{overload.Item1.NativeEntrypoint}\", " +
                    $"Source = \"{overload.Item1.Source}\"" +
                    $")]"
                );
                await sw.WriteAsync("        public ");
                var decl = GetDeclarationString(overload.Item1);
                if (!decl.Contains("unsafe "))
                {
                    await sw.WriteAsync("unsafe ");
                }

                await sw.WriteLineAsync(decl);
                await sw.WriteLineAsync("        {");
                foreach (var line in overload.Item2.ToString().Split(new[] { '\n' }, StringSplitOptions.RemoveEmptyEntries))
                {
                    await sw.WriteAsync("            " + line);
                }

                await sw.WriteLineAsync("        }");
                await sw.WriteLineAsync();
            }

            await sw.WriteLineAsync("    }");
            await sw.WriteLineAsync("}");
            sw.Dispose();
        }

        private static async Task WriteTemplateMixedModePartAsync
        (
            Project project,
            string name,
            string file,
            string ns,
            bool ext
        )
        {
            var sw = new StreamWriter(File.Open(file, FileMode.Create, FileAccess.ReadWrite, FileShare.Inheritable));
            await sw.WriteLineAsync(EmbeddedResources.LicenseText(Path.GetFileName(file)));
            await sw.WriteLineAsync("using System;");
            await sw.WriteLineAsync("using System.Runtime.InteropServices;");
            await sw.WriteLineAsync("using System.Text;");
            await sw.WriteLineAsync("using AdvancedDLSupport;");
            await sw.WriteLineAsync("using OpenToolkit.Core.Loader;");
            await sw.WriteLineAsync("using OpenToolkit.Core.Native;");
            await sw.WriteLineAsync();
            await sw.WriteLineAsync("namespace " + ns);
            await sw.WriteLineAsync("{");
            var @base = !ext ? "NativeLibraryBase" : "ExtensionBase";
            var nm = ns.Split('.').Last();
            await sw.WriteLineAsync("    public partial class " + name + " : " + @base + ", I" + name);
            await sw.WriteLineAsync("    {");
            await sw.WriteLineAsync("        /// <inheritdoc cref=\"" + @base + "\"/>");
            await sw.WriteLineAsync("        protected " + name + "(string path, ImplementationOptions options)");
            await sw.WriteLineAsync("            : base(path, options)");
            await sw.WriteLineAsync("        {");
            await sw.WriteLineAsync("        }");
            await sw.WriteLineAsync();
            await sw.WriteLineAsync("        /// <summary>");
            await sw.WriteLineAsync("        /// Gets the library name container for this profile.");
            await sw.WriteLineAsync("        /// </summary>");
            await sw.WriteAsync("        public IPlatformLibraryNameContainer NameContainer => new");
            await sw.WriteLineAsync(" " + nm + "LibraryNameContainer();");
            await sw.WriteLineAsync("    }");
            await sw.WriteLineAsync("}");
            sw.Dispose();
        }
    }
}
