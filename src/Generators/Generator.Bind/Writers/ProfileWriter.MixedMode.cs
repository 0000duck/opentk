using System;
using System.IO;
using System.Linq;
using System.Threading.Tasks;
using Bind.Structure;

namespace Bind.Writers
{
    internal partial class ProfileWriter
    {
        /// <summary>
        /// Writes a mixed mode class for the given project.
        /// </summary>
        /// <param name="project">The project to write a mixed-mode class for.</param>
        /// <param name="name">The full name of an API profile (e.g. OpenGL or OpenGLES).</param>
        /// <param name="dir">The directory to write mixed-mode class parts to.</param>
        /// <param name="ns">The namespace of the mixed-mode-class.</param>
        /// <param name="ext">Whether this project is an extension or not.</param>
        /// <returns>An asynchronous task.</returns>
        public static async Task WriteMixedModeClassAsync(Project project, string name, string dir, string ns, bool ext)
        {
            await WriteOverloadsMixedModePartAsync(project, name, Path.Combine(dir, "GL.Overloads.cs"), ns);
            await WriteNativeMixedModePartAsync(project, name, Path.Combine(dir, "GL.Native.cs"), ns);
            if (!File.Exists(Path.Combine(dir, "GL.cs")))
            {
                await WriteTemplateMixedModePartAsync(project, name, Path.Combine(dir, "GL.cs"), ns, ext);
            }
        }

        private static async Task WriteNativeMixedModePartAsync(Project project, string name, string file, string ns)
        {
            var sw = new StreamWriter(File.Open(file, FileMode.Create, FileAccess.ReadWrite, FileShare.Inheritable));
            await sw.WriteLineAsync("// <auto-generated />");
            await sw.WriteLineAsync(EmbeddedResources.LicenseText);
            await sw.WriteLineAsync("using AdvancedDLSupport;");
            await sw.WriteLineAsync("using OpenToolkit.Core.Native;");
            await sw.WriteLineAsync("using System;");
            await sw.WriteLineAsync("using System.Runtime.InteropServices;");
            await sw.WriteLineAsync("using System.Text;");
            await sw.WriteLineAsync();
            await sw.WriteLineAsync("namespace " + ns);
            await sw.WriteLineAsync("{");
            await sw.WriteLineAsync("    public abstract partial class " + name);
            await sw.WriteLineAsync("    {");
            foreach (var func in project.Interfaces.SelectMany(x => x.Functions))
            {
                await sw.WriteLineAsync("        /// <inheritdoc/>");
                await sw.WriteAsync("        public abstract ");
                await sw.WriteLineAsync(GetDeclarationString(func) + ";");
                await sw.WriteLineAsync();
            }

            await sw.WriteLineAsync("    }");
            await sw.WriteLineAsync("}");
            sw.Dispose();
        }

        private static async Task WriteOverloadsMixedModePartAsync(Project project, string name, string file, string ns)
        {
            var sw = new StreamWriter(File.Open(file, FileMode.Create, FileAccess.ReadWrite, FileShare.Inheritable));
            await sw.WriteLineAsync("// <auto-generated />");
            await sw.WriteLineAsync(EmbeddedResources.LicenseText);
            await sw.WriteLineAsync("using AdvancedDLSupport;");
            await sw.WriteLineAsync("using OpenToolkit.Core.Native;");
            await sw.WriteLineAsync("using System;");
            await sw.WriteLineAsync("using System.Runtime.InteropServices;");
            await sw.WriteLineAsync("using System.Text;");
            await sw.WriteLineAsync();
            await sw.WriteLineAsync("namespace " + ns);
            await sw.WriteLineAsync("{");
            await sw.WriteLineAsync("    public partial class " + name);
            await sw.WriteLineAsync("    {");
            foreach (var overload in project.Overloads)
            {
                await sw.WriteAsync("        public ");
                await sw.WriteLineAsync(GetDeclarationString(overload.Item1));
                await sw.WriteLineAsync("        {");
                foreach (var line in overload.Item2.ToString().Split(new[] { '\n' }, StringSplitOptions.RemoveEmptyEntries))
                {
                    await sw.WriteAsync("            " + line);
                }

                await sw.WriteLineAsync("        }");
                await sw.WriteLineAsync();
            }

            await sw.WriteLineAsync("    }");
            await sw.WriteLineAsync("}");
            sw.Dispose();
        }

        private static async Task WriteTemplateMixedModePartAsync
        (
            Project project,
            string name,
            string file,
            string ns,
            bool ext
        )
        {
            var sw = new StreamWriter(File.Open(file, FileMode.Create, FileAccess.ReadWrite, FileShare.Inheritable));
            await sw.WriteLineAsync("// <auto-generated />");
            await sw.WriteLineAsync(EmbeddedResources.LicenseText);
            await sw.WriteLineAsync("using AdvancedDLSupport;");
            await sw.WriteLineAsync("using OpenToolkit.Core.Native;");
            await sw.WriteLineAsync("using System;");
            await sw.WriteLineAsync("using System.Runtime.InteropServices;");
            await sw.WriteLineAsync("using System.Text;");
            await sw.WriteLineAsync();
            await sw.WriteLineAsync("namespace " + ns);
            await sw.WriteLineAsync("{");
            var @base = !ext ? "NativeLibraryBase" : "ExtensionBase";
            var nm = ns.Split('.').Last();
            await sw.WriteLineAsync("    public partial class " + name + " : " + @base + ", I" + name);
            await sw.WriteLineAsync("    {");
            await sw.WriteLineAsync("        /// <inheritdoc cref=\"" + @base + "\"/>");
            await sw.WriteLineAsync("        protected " + name + "(string path, ImplementationOptions options)");
            await sw.WriteLineAsync("            : base(path, options)");
            await sw.WriteLineAsync("        {");
            await sw.WriteLineAsync("        }");
            await sw.WriteLineAsync();
            await sw.WriteAsync("        public IPlatformLibraryNameContainer NameContainer => new");
            await sw.WriteLineAsync(" " + nm + "LibraryNameContainer();");
            await sw.WriteLineAsync("    }");
            await sw.WriteLineAsync("}");
            sw.Dispose();
        }
    }
}
