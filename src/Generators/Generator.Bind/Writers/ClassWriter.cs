using System;
using System.IO;
using System.Linq;
using System.Threading.Tasks;
using Bind.Generators;
using Bind.Structure;
using Bind.Translation.Translators;

namespace Bind.Writers
{
    /// <summary>
    /// Contains methods to write mixed-mode classes for projects, to be used with AdvancedDLSupport.
    /// </summary>
    internal static class ClassWriter
    {
        /// <summary>
        /// Writes a mixed mode class for the given project.
        /// </summary>
        /// <param name="project">The project to write a mixed-mode class for.</param>
        /// <param name="settings">The generator settings used to configure the mixed-mode class writer.</param>
        /// <returns>An asynchronous task.</returns>
        public static async Task WriteMixedModeClassAsync(Project project, IGeneratorSettings settings)
        {
            var ext = project.Extension != "Core";
            var ns = project.Extension == "Core"
                ? settings.Namespace
                : settings.ExtensionNamespace + "." + Utilities.ConvertExtensionNameToNamespace(project.Extension);
            var dir = project.Extension == "Core"
                ? Path.Combine(settings.OutputSubfolder, settings.Namespace, settings.ClassName)
                : Path.Combine(settings.OutputSubfolder, ProfileWriter.ExtensionsFolder, ns);
            await WriteOverloadsMixedModePartAsync(project, settings);
            await WriteNativeMixedModePartAsync(project, settings);
            if (!File.Exists(Path.Combine(dir, $"{settings.ClassName}.cs")) && !ext)
            {
                await WriteTemplateMixedModePartAsync(project, settings);
            }
        }

        private static async Task WriteNativeMixedModePartAsync
            (Project project, IGeneratorSettings settings)
        {
            var file = project.Extension == "Core"
                ? settings.ClassName
                : NativeIdentifierTranslator.TranslateIdentifierName(project.Extension);
            var ns = project.Extension == "Core"
                ? settings.Namespace
                : settings.ExtensionNamespace + "." + Utilities.ConvertExtensionNameToNamespace(project.Extension);
            using (var sw = new StreamWriter(File.Open(file + ".Native.cs", FileMode.Create, FileAccess.ReadWrite, FileShare.Inheritable)))
            {
                sw.WriteLine("// <auto-generated />");
                sw.WriteLine(EmbeddedResources.LicenseText(Path.GetFileName(file)));
                sw.WriteLine("using AdvancedDLSupport;");
                sw.WriteLine("using OpenToolkit.Core.Native;");
                sw.WriteLine("using OpenToolkit.Core.Loader;");
                sw.WriteLine("using OpenToolkit.Core.Extensions;");
                sw.WriteLine("using " + settings.Namespace + ";");
                sw.WriteLine("using System;");
                sw.WriteLine("using System.Runtime.InteropServices;");
                sw.WriteLine("using System.Text;");
                sw.WriteLine();
                sw.WriteLine("namespace " + ns);
                sw.WriteLine("{");
                if (project.Extension != "Core")
                {
                    sw.WriteLine($"    [Extension(\"{settings.ConstantPrefix}{project.Extension}\")]");
                }

                sw.Write("    public abstract partial class " + file);
                if (project.Extension != "Core")
                {
                    sw.WriteLine(" : ExtensionBase, I" + file);
                    sw.WriteLine("    {");
                    sw.WriteLine("        /// <inheritdoc cref=\"ExtensionBase\"/>");
                    sw.WriteLine($"        protected {file}(string path, ImplementationOptions options)");
                    sw.WriteLine("            : base(path, options)");
                    sw.WriteLine("        {");
                    sw.WriteLine("        }");
                    sw.WriteLine();
                }
                else
                {
                    sw.WriteLine();
                    sw.WriteLine("    {");
                }

                foreach (var func in project.Interfaces.SelectMany(x => x.Functions))
                {
                    sw.WriteLine("        /// <inheritdoc/>");
                    sw.Write("        public abstract ");
                    sw.WriteLine(Utilities.GetDeclarationString(func) + ";");
                    sw.WriteLine();
                }

                sw.WriteLine("    }");
                sw.WriteLine("}");
                await sw.FlushAsync();
            }
        }

        private static async Task WriteOverloadsMixedModePartAsync(Project project, IGeneratorSettings settings)
        {
            var file = project.Extension == "Core"
                ? settings.ClassName
                : NativeIdentifierTranslator.TranslateIdentifierName(project.Extension);
            var ns = project.Extension == "Core"
                ? settings.Namespace
                : settings.ExtensionNamespace + "." + Utilities.ConvertExtensionNameToNamespace(project.Extension);
            using (var sw = new StreamWriter(File.Open(file + ".Overloads.cs", FileMode.Create, FileAccess.ReadWrite, FileShare.Inheritable)))
            {
                sw.WriteLine("// <auto-generated />");
                sw.WriteLine(EmbeddedResources.LicenseText(Path.GetFileName(file)));
                sw.WriteLine("using AdvancedDLSupport;");
                sw.WriteLine("using OpenToolkit.Core.Native;");
                sw.WriteLine("using OpenToolkit.Core.Extensions;");
                sw.WriteLine("using System;");
                sw.WriteLine("using System.Runtime.InteropServices;");
                sw.WriteLine("using System.Text;");
                sw.WriteLine("using " + settings.Namespace + ";");
                sw.WriteLine();
                sw.WriteLine("namespace " + ns);
                sw.WriteLine("{");
                sw.WriteLine("    public partial class " + file);
                sw.WriteLine("    {");
                foreach (var overload in project.Overloads)
                {
                    sw.WriteLine
                    (
                        $"        " +
                        $"[AutoGenerated(" +
                        $"Category = \"{overload.Item1.Categories.First()}\", " +
                        $"Version = \"{overload.Item1.IntroducedIn}\", " +
                        $"EntryPoint = \"{settings.FunctionPrefix}{overload.Item1.NativeEntrypoint}\", " +
                        $"Source = \"{overload.Item1.Source}\"" +
                        $")]"
                    );
                    sw.Write("        public ");
                    var decl = Utilities.GetDeclarationString(overload.Item1);
                    if (!decl.Contains("unsafe "))
                    {
                        sw.Write("unsafe ");
                    }

                    sw.WriteLine(decl);
                    sw.WriteLine("        {");
                    foreach (var line in overload.Item2.ToString()
                        .Split(new[] {'\n'}, StringSplitOptions.RemoveEmptyEntries))
                    {
                        sw.Write("            " + line);
                    }

                    sw.WriteLine("        }");
                    sw.WriteLine();
                }

                sw.WriteLine("    }");
                sw.WriteLine("}");
                await sw.FlushAsync();
            }
        }

        private static async Task WriteTemplateMixedModePartAsync
        (
            Project project,
            IGeneratorSettings settings
        )
        {
            using (var sw = new StreamWriter(File.Open(settings.ClassName + ".cs", FileMode.Create, FileAccess.ReadWrite, FileShare.Inheritable)))
            {
                sw.WriteLine(EmbeddedResources.LicenseText(Path.GetFileName(settings.ClassName + ".cs")));
                sw.WriteLine("using System;");
                sw.WriteLine("using System.Runtime.InteropServices;");
                sw.WriteLine("using System.Text;");
                sw.WriteLine("using AdvancedDLSupport;");
                sw.WriteLine("using OpenToolkit.Core.Loader;");
                sw.WriteLine("using OpenToolkit.Core.Native;");
                sw.WriteLine();
                sw.WriteLine("namespace " + settings.Namespace);
                sw.WriteLine("{");
                var nm = settings.Namespace.Split('.').Last();
                sw.WriteLine("    public partial class " + settings.ClassName + " : NativeLibraryBase, I" + settings.ClassName);
                sw.WriteLine("    {");
                sw.WriteLine("        /// <inheritdoc cref=\"NativeLibraryBase\"/>");
                sw.WriteLine("        protected " + settings.ClassName + "(string path, ImplementationOptions options)");
                sw.WriteLine("            : base(path, options)");
                sw.WriteLine("        {");
                sw.WriteLine("        }");
                sw.WriteLine();
                sw.WriteLine("        /// <summary>");
                sw.WriteLine("        /// Gets the library name container for this profile.");
                sw.WriteLine("        /// </summary>");
                sw.Write("        public IPlatformLibraryNameContainer NameContainer => new");
                sw.WriteLine(" " + nm + "LibraryNameContainer();");
                sw.WriteLine("    }");
                sw.WriteLine("}");
                await sw.FlushAsync();
            }
        }
    }
}
